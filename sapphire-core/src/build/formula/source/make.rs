// FILE: sapphire-core/src/build/formula/source/make.rs

use std::fs;
use std::io::Read;
use std::os::unix::fs::PermissionsExt;
use std::path::Path;
use std::process::Command;

use tracing::{debug, error};

use crate::build::env::BuildEnvironment;
use crate::build::formula::source::run_command_in_dir;
use crate::utils::error::{Result, SapphireError};

fn is_gnu_autotools_configure(script_path: &Path) -> bool {
    const READ_BUFFER_SIZE: usize = 4096;
    const AUTOCONF_MARKERS: &[&str] = &[
        "Generated by GNU Autoconf",
        "generated by autoconf",
        "config.status:",
    ];

    let mut buffer = String::with_capacity(READ_BUFFER_SIZE);
    match fs::File::open(script_path).and_then(|mut file| file.read_to_string(&mut buffer)) {
        Ok(_) => {
            for marker in AUTOCONF_MARKERS {
                if buffer.contains(marker) {
                    debug!(
                        "Detected Autotools marker ('{}') in {}",
                        marker,
                        script_path.display()
                    );
                    return true;
                }
            }
            debug!(
                "No specific Autotools markers found in {}",
                script_path.display()
            );
            false
        }
        Err(e) => {
            debug!(
                "Could not read {} to check for Autotools: {}.",
                script_path.display(),
                e
            );
            false
        }
    }
}

pub fn configure_and_make(
    source_dir: &Path,
    install_dir: &Path,
    build_env: &BuildEnvironment,
) -> Result<()> {
    debug!("Configuring and Making in {}", source_dir.display());
    let configure_script_path = source_dir.join("configure");

    if !configure_script_path.exists() {
        return Err(SapphireError::BuildEnvError(format!(
            "./configure script not found in {}",
            source_dir.display()
        )));
    }

    let is_autotools = is_gnu_autotools_configure(&configure_script_path);

    debug!("Running ./configure --prefix={}", install_dir.display());
    if is_autotools {
        debug!("    (Detected Autotools flags)");
    }

    let mut cmd_configure = Command::new("./configure");
    cmd_configure.arg(format!("--prefix={}", install_dir.display()));
    if is_autotools {
        cmd_configure.args(["--disable-dependency-tracking", "--disable-silent-rules"]);
    }

    let configure_output =
        run_command_in_dir(&mut cmd_configure, source_dir, build_env, "configure")?;
    debug!(
        "Configure stdout:\n{}",
        String::from_utf8_lossy(&configure_output.stdout)
    );
    debug!(
        "Configure stderr:\n{}",
        String::from_utf8_lossy(&configure_output.stderr)
    );

    let make_exe = which::which_in("make", build_env.get_path_string(), source_dir)
        .or_else(|_| which::which("make"))
        .map_err(|_| SapphireError::BuildEnvError("make command not found.".to_string()))?;

    debug!("Running make");
    let mut cmd_make = Command::new(make_exe.clone());
    run_command_in_dir(&mut cmd_make, source_dir, build_env, "make")?;
    debug!("Make completed successfully.");

    debug!("Running make install");
    let mut cmd_install = Command::new(make_exe);
    cmd_install.arg("install");
    run_command_in_dir(&mut cmd_install, source_dir, build_env, "make install")?;
    debug!("Make install completed successfully.");

    Ok(())
}

pub fn simple_make(
    source_dir: &Path,
    install_dir: &Path,
    build_env: &BuildEnvironment,
) -> Result<()> {
    let make_exe = which::which_in("make", build_env.get_path_string(), source_dir)
        .or_else(|_| which::which("make"))
        .map_err(|_| SapphireError::BuildEnvError("make command not found.".to_string()))?;

    debug!("Running make");
    let mut cmd_make = Command::new(make_exe.clone());
    let make_output = run_command_in_dir(&mut cmd_make, source_dir, build_env, "make")?;
    debug!("Make completed successfully.");
    debug!(
        "Make stdout:\n{}",
        String::from_utf8_lossy(&make_output.stdout)
    );
    debug!(
        "Make stderr:\n{}",
        String::from_utf8_lossy(&make_output.stderr)
    );

    debug!("Running make install PREFIX={}", install_dir.display());
    let mut cmd_install = Command::new(make_exe);
    cmd_install.arg("install");
    cmd_install.arg(format!("PREFIX={}", install_dir.display()));

    let install_output_result = run_command_in_dir(
        &mut cmd_install,
        source_dir,
        build_env,
        "make install (simple)",
    );
    let make_install_succeeded = install_output_result.is_ok();

    if !make_install_succeeded {
        debug!("'make install' failed. Will check for manually installable artifacts.");
        // Corrected line: Collapsed the nested if let
        if let Err(SapphireError::CommandExecError(msg)) = &install_output_result {
            // Use '&' to borrow
            if let Some(output) = extract_output_from_exec_error(msg) {
                debug!(
                    "Make install stdout:\n{}",
                    String::from_utf8_lossy(&output.stdout)
                );
                debug!(
                    "Make install stderr:\n{}",
                    String::from_utf8_lossy(&output.stderr)
                );
            }
        }
    } else {
        debug!("Make install completed successfully.");
        if let Ok(ref output) = install_output_result {
            debug!(
                "Make install stdout:\n{}",
                String::from_utf8_lossy(&output.stdout)
            );
            debug!(
                "Make install stderr:\n{}",
                String::from_utf8_lossy(&output.stderr)
            );
        }
    }

    let bin_dir = install_dir.join("bin");
    let bin_populated =
        bin_dir.exists() && bin_dir.read_dir().is_ok_and(|mut d| d.next().is_some());

    if !bin_populated {
        debug!(
            "Installation directory '{}' is empty after 'make install'. Attempting manual artifact installation.",
            bin_dir.display()
        );

        let formula_name = install_dir
            .parent()
            .and_then(|p| p.file_name())
            .and_then(|n| n.to_str())
            .unwrap_or("");
        let potential_binary_path = source_dir.join(formula_name);
        let mut found_and_installed_manually = false;

        if !formula_name.is_empty() && potential_binary_path.is_file() {
            debug!(
                "Found potential binary '{}'. Manually installing...",
                potential_binary_path.display()
            );
            fs::create_dir_all(&bin_dir)?;

            let target_path = bin_dir.join(formula_name);
            fs::copy(&potential_binary_path, &target_path).map_err(|e| {
                SapphireError::Io(std::io::Error::new(
                    e.kind(),
                    format!("Failed copy binary: {e}"),
                ))
            })?;

            #[cfg(unix)]
            {
                let mut perms = fs::metadata(&target_path)?.permissions();
                perms.set_mode(0o755);
                fs::set_permissions(&target_path, perms)?;
                debug!("Set executable permissions on {}", target_path.display());
            }

            found_and_installed_manually = true;
        } else {
            debug!(
                "Could not find executable named '{}' in build directory for manual installation.",
                formula_name
            );
        }

        if !make_install_succeeded && !found_and_installed_manually {
            error!("make install failed and could not find/install artifacts manually.");
            // Return the original error by propagating it
            return install_output_result.map(|_| ());
        } else if !found_and_installed_manually && make_install_succeeded {
            debug!("make install reported success, but '{}' was not populated and no executable found manually.", bin_dir.display());
        }
    } else {
        debug!(
            "Installation directory '{}' appears populated.",
            bin_dir.display()
        );
    }

    Ok(())
}

fn extract_output_from_exec_error(msg: &str) -> Option<std::process::Output> {
    // This is a basic heuristic, might need refinement
    // We assume the `run_command_in_dir` error format includes Status/Stdout/Stderr strings
    // It's better if `run_command_in_dir` returns the Output struct on error.
    // For now, we return None as we can't reliably parse it back.
    let _ = msg; // Avoid unused warning
    None
}
